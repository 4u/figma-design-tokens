"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.identity = void 0;
exports.typeDef = typeDef;
exports.fromFn = fromFn;
exports.extendType = extendType;
var from_1 = require("./from");
Object.defineProperty(exports, "identity", { enumerable: true, get: function () { return from_1.identity; } });
/**
 * Get the type definitions or an empty object from a type or a decoding function
 */
function typeDef(from) {
    if (typeof from === "function") {
        return {};
    }
    return from;
}
/**
 * Get the decoding function from a type or a function
 */
function fromFn(t) {
    if (typeof t === "function") {
        return t;
    }
    return t.from;
}
/**
 * Extend a type: take a type and use it as a base for another type. Much like using the spread operator:
 * ```
 * const newType = { ...oldType }
 * ```
 * but composes the `from` arguments
 *
 * @param base A base type from `InputA` to `OutputA`
 * @param nextTypeOrDecodingFunction Either an entire `Type<OutputA, AnyOutput>` or just a decoding function from `OutputA` to any type
 */
function extendType(base, nextTypeOrDecodingFunction) {
    const { defaultValue: _defaultValue, onMissing: _onMissing, from: _from, ...t1WithoutDefault } = base;
    const t2Object = typeDef(nextTypeOrDecodingFunction);
    const t2From = fromFn(nextTypeOrDecodingFunction);
    return {
        ...t1WithoutDefault,
        ...t2Object,
        async from(a) {
            const f1Result = await base.from(a);
            return await t2From(f1Result);
        },
    };
}
//# sourceMappingURL=type.js.map